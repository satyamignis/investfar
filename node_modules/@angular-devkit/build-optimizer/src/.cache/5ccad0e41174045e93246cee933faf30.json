{"remainingRequest":"/var/www/html/2019/fab/investfarNew/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--8-1!/var/www/html/2019/fab/investfarNew/node_modules/ng-simple-slideshow/ng-simple-slideshow.es5.js","dependencies":[{"path":"/var/www/html/2019/fab/investfarNew/node_modules/ng-simple-slideshow/ng-simple-slideshow.es5.js","mtime":499162500000},{"path":"/var/www/html/2019/fab/investfarNew/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/var/www/html/2019/fab/investfarNew/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1528256844000}],"contextDependencies":[],"result":["import { Component, EventEmitter, Inject, Injectable, Input, NgModule, NgZone, Output, PLATFORM_ID, Renderer2, ViewChild } from '@angular/core';\nimport { CommonModule, DOCUMENT, isPlatformServer } from '@angular/common';\nimport { BrowserTransferStateModule, DomSanitizer, TransferState, makeStateKey } from '@angular/platform-browser';\nvar SwipeService = /** @class */ /*@__PURE__*/ (function () {\n    function SwipeService() {\n    }\n    /**\n     * \\@description detect the direction of the swipe, and return a -1 or 1 if the duration is long enough\n     *              else return a 0 to do nothing\n     * @param {?} e\n     * @param {?} when\n     * @return {?}\n     */\n    SwipeService.prototype.swipe = function (e, when) {\n        var /** @type {?} */ coord = [e.changedTouches[0].pageX, e.changedTouches[0].pageY];\n        var /** @type {?} */ time = new Date().getTime();\n        if (when === 'start') {\n            this._swipeCoord = coord;\n            this._swipeTime = time;\n        }\n        else if (when === 'end') {\n            var /** @type {?} */ direction = [coord[0] - this._swipeCoord[0], coord[1] - this._swipeCoord[1]];\n            var /** @type {?} */ duration = time - this._swipeTime;\n            if (duration < 1000 // Short enough\n                && Math.abs(direction[1]) < Math.abs(direction[0]) // Horizontal enough\n                && Math.abs(direction[0]) > 30) {\n                return direction[0] < 0 ? 1 : -1;\n            }\n        }\n        return 0;\n    };\n    return SwipeService;\n}());\nvar FIRST_SLIDE_KEY = makeStateKey('firstSlide');\nvar SlideshowComponent = /** @class */ /*@__PURE__*/ (function () {\n    /**\n     * @param {?} _swipeService\n     * @param {?} _renderer\n     * @param {?} _transferState\n     * @param {?} _ngZone\n     * @param {?} sanitizer\n     * @param {?} platform_id\n     * @param {?} document\n     */\n    function SlideshowComponent(_swipeService, _renderer, _transferState, _ngZone, sanitizer, platform_id, document) {\n        this._swipeService = _swipeService;\n        this._renderer = _renderer;\n        this._transferState = _transferState;\n        this._ngZone = _ngZone;\n        this.sanitizer = sanitizer;\n        this.platform_id = platform_id;\n        this.document = document;\n        this.slideIndex = 0;\n        this.slides = [];\n        this._initial = true;\n        this._isHidden = false;\n        this.imageUrls = [];\n        this.height = '100%';\n        this.showArrows = true;\n        this.disableSwiping = false;\n        this.autoPlay = false;\n        this.autoPlayInterval = 3333;\n        this.stopAutoPlayOnSlide = true;\n        this.autoPlayWaitForLazyLoad = false;\n        this.backgroundSize = 'cover';\n        this.backgroundPosition = 'center center';\n        this.backgroundRepeat = 'no-repeat';\n        this.showDots = false;\n        this.dotColor = '#FFF';\n        this.showCaptions = true;\n        this.captionColor = '#FFF';\n        this.captionBackground = 'rgba(0, 0, 0, .35)';\n        this.lazyLoad = false;\n        this.hideOnNoSlides = false;\n        this.fullscreen = false;\n        this.onSlideLeft = new EventEmitter();\n        this.onSlideRight = new EventEmitter();\n        this.onSwipeLeft = new EventEmitter();\n        this.onSwipeRight = new EventEmitter();\n    }\n    Object.defineProperty(SlideshowComponent.prototype, \"safeStyleDotColor\", {\n        /**\n         * @return {?}\n         */\n        get: function () {\n            return this.sanitizer.bypassSecurityTrustStyle(\"--dot-color: \" + this.dotColor);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    SlideshowComponent.prototype.ngOnInit = function () {\n        if (this.debug !== undefined) {\n            console.warn('[Deprecation Warning]: The debug input will be removed from ng-simple-slideshow in 1.3.0');\n        }\n    };\n    /**\n     * @return {?}\n     */\n    SlideshowComponent.prototype.ngDoCheck = function () {\n        // if this is the first being called, create a copy of the input\n        if (this.imageUrls && this.imageUrls.length > 0) {\n            if (this._initial === true) {\n                this._urlCache = Array.from(this.imageUrls);\n            }\n            if (this._isHidden === true) {\n                this._renderer.removeStyle(this.container.nativeElement, 'display');\n                this._isHidden = false;\n            }\n            this.setSlides();\n        }\n        else if (this.hideOnNoSlides === true) {\n            this._renderer.setStyle(this.container.nativeElement, 'display', 'none');\n            this._isHidden = true;\n        }\n        this.setStyles();\n        this.handleAutoPlay();\n    };\n    /**\n     * \\@description this is the function that should be called to make the slides change.\n     *              indexDirection to move back is -1, to move forward is 1, and to stay in place is 0.\n     *              0 is taken into account for failed swipes\n     * @param {?} indexDirection\n     * @param {?=} isSwipe\n     * @return {?}\n     */\n    SlideshowComponent.prototype.onSlide = function (indexDirection, isSwipe) {\n        this.handleAutoPlay(this.stopAutoPlayOnSlide);\n        this.slide(indexDirection, isSwipe);\n    };\n    /**\n     * \\@description Use the swipe service to detect swipe events from phone and tablets\n     * @param {?} e\n     * @param {?} when\n     * @return {?}\n     */\n    SlideshowComponent.prototype.onSwipe = function (e, when) {\n        if (this.disableSwiping === true) {\n            return;\n        }\n        var /** @type {?} */ indexDirection = this._swipeService.swipe(e, when);\n        // handle a failed swipe\n        if (indexDirection === 0) {\n            return;\n        }\n        else {\n            this.onSlide(indexDirection, true);\n        }\n    };\n    /**\n     * \\@description Redirect to current slide \"href\" if defined\n     * @param {?} e\n     * @return {?}\n     */\n    SlideshowComponent.prototype.onClick = function (e) {\n        e.preventDefault();\n        var /** @type {?} */ currentSlide = this.slides.length > 0 && this.slides[this.slideIndex];\n        if (currentSlide && currentSlide.image.clickAction) {\n            currentSlide.image.clickAction();\n        }\n        else if (currentSlide && currentSlide.image.href) {\n            this.document.location.href = currentSlide.image.href;\n        }\n    };\n    /**\n     * \\@description set the index to the desired index - 1 and simulate a right slide\n     * @param {?} index\n     * @return {?}\n     */\n    SlideshowComponent.prototype.goToSlide = function (index) {\n        var /** @type {?} */ beforeClickIndex = this.slideIndex;\n        this.slideIndex = index - 1;\n        this.setSlideIndex(1);\n        if (!this.slides[this.slideIndex].loaded) {\n            this.loadRemainingSlides();\n        }\n        this.handleAutoPlay(this.stopAutoPlayOnSlide);\n        this.slideRight(beforeClickIndex);\n        this.slides[beforeClickIndex].selected = false;\n        this.slides[this.slideIndex].selected = true;\n    };\n    /**\n     * \\@description set the index to the desired index - 1 and simulate a right slide\n     * @param {?} index\n     * @return {?}\n     */\n    SlideshowComponent.prototype.getSlideStyle = function (index) {\n        var /** @type {?} */ slide = this.slides[index];\n        if (slide.loaded) {\n            return {\n                \"background-image\": 'url(' + slide.image.url + ')',\n                \"background-size\": slide.image.backgroundSize || this.backgroundSize,\n                \"background-position\": slide.image.backgroundPosition || this.backgroundPosition,\n                \"background-repeat\": slide.image.backgroundRepeat || this.backgroundRepeat\n            };\n        }\n        else {\n            // doesn't compile correctly if returning an empty object, sooooo.....\n            return {\n                \"background-image\": undefined,\n                \"background-size\": undefined,\n                \"background-position\": undefined,\n                \"background-repeat\": undefined\n            };\n        }\n    };\n    /**\n     * @return {?}\n     */\n    SlideshowComponent.prototype.exitFullScreen = function () {\n        this.fullscreen = false;\n    };\n    /**\n     * \\@description Set the new slide index, then make the transition happen.\n     * @param {?} indexDirection\n     * @param {?=} isSwipe\n     * @return {?}\n     */\n    SlideshowComponent.prototype.slide = function (indexDirection, isSwipe) {\n        var /** @type {?} */ oldIndex = this.slideIndex;\n        this.setSlideIndex(indexDirection);\n        if (!this.slides[this.slideIndex].loaded) {\n            this.loadRemainingSlides();\n        }\n        if (indexDirection === 1) {\n            this.slideRight(oldIndex, isSwipe);\n        }\n        else {\n            this.slideLeft(oldIndex, isSwipe);\n        }\n        this.slides[oldIndex].selected = false;\n        this.slides[this.slideIndex].selected = true;\n    };\n    /**\n     * \\@description This is just treating the url array like a circular list.\n     * @param {?} indexDirection\n     * @return {?}\n     */\n    SlideshowComponent.prototype.setSlideIndex = function (indexDirection) {\n        this.slideIndex += indexDirection;\n        if (this.slideIndex < 0) {\n            this.slideIndex = this.slides.length - 1;\n        }\n        if (this.slideIndex >= this.slides.length) {\n            this.slideIndex = 0;\n        }\n    };\n    /**\n     * \\@description This function handles the variables to move the CSS classes around accordingly.\n     *              In order to correctly handle animations, the new slide as well as the slides to\n     *              the left and right are assigned classes.\n     * @param {?} oldIndex\n     * @param {?=} isSwipe\n     * @return {?}\n     */\n    SlideshowComponent.prototype.slideLeft = function (oldIndex, isSwipe) {\n        if (isSwipe === true) {\n            this.onSwipeLeft.emit(this.slideIndex);\n        }\n        else {\n            this.onSlideLeft.emit(this.slideIndex);\n        }\n        this.slides[this.getLeftSideIndex(oldIndex)].leftSide = false;\n        this.slides[oldIndex].leftSide = true;\n        this.slides[oldIndex].action = 'slideOutLeft';\n        this.slides[this.slideIndex].rightSide = false;\n        this.slides[this.getRightSideIndex()].rightSide = true;\n        this.slides[this.slideIndex].action = 'slideInRight';\n    };\n    /**\n     * \\@description This function handles the variables to move the CSS classes around accordingly.\n     *              In order to correctly handle animations, the new slide as well as the slides to\n     *              the left and right are assigned classes.\n     * @param {?} oldIndex\n     * @param {?=} isSwipe\n     * @return {?}\n     */\n    SlideshowComponent.prototype.slideRight = function (oldIndex, isSwipe) {\n        if (isSwipe === true) {\n            this.onSwipeRight.emit(this.slideIndex);\n        }\n        else {\n            this.onSlideRight.emit(this.slideIndex);\n        }\n        this.slides[this.getRightSideIndex(oldIndex)].rightSide = false;\n        this.slides[oldIndex].rightSide = true;\n        this.slides[oldIndex].action = 'slideOutRight';\n        this.slides[this.slideIndex].leftSide = false;\n        this.slides[this.getLeftSideIndex()].leftSide = true;\n        this.slides[this.slideIndex].action = 'slideInLeft';\n    };\n    /**\n     * \\@description Check to make sure slide images have been set or haven't changed\n     * @return {?}\n     */\n    SlideshowComponent.prototype.setSlides = function () {\n        if (this.imageUrls) {\n            if (this.checkCache() || this._initial === true) {\n                this._initial = false;\n                this._urlCache = Array.from(this.imageUrls);\n                this.slides = [];\n                if (this.lazyLoad === true) {\n                    this.buildLazyLoadSlideArray();\n                }\n                else {\n                    this.buildSlideArray();\n                }\n            }\n        }\n    };\n    /**\n     * \\@description create the slides without background urls, which will be added in\n     *              for the \"lazy load,\" then load only the first slide\n     * @return {?}\n     */\n    SlideshowComponent.prototype.buildLazyLoadSlideArray = function () {\n        for (var _i = 0, _a = this.imageUrls; _i < _a.length; _i++) {\n            var image = _a[_i];\n            this.slides.push({\n                image: (typeof image === 'string' ? { url: null } : { url: null, href: image.href || '' }),\n                action: '',\n                leftSide: false,\n                rightSide: false,\n                selected: false,\n                loaded: false\n            });\n        }\n        this.slides[this.slideIndex].selected = true;\n        this.loadFirstSlide();\n    };\n    /**\n     * \\@description create the slides with background urls all at once\n     * @return {?}\n     */\n    SlideshowComponent.prototype.buildSlideArray = function () {\n        for (var _i = 0, _a = this.imageUrls; _i < _a.length; _i++) {\n            var image = _a[_i];\n            this.slides.push({\n                image: (typeof image === 'string' ? { url: image } : image),\n                action: '',\n                leftSide: false,\n                rightSide: false,\n                selected: false,\n                loaded: true\n            });\n        }\n        this.slides[this.slideIndex].selected = true;\n    };\n    /**\n     * \\@description load the first slide image if lazy loading\n     *              this takes server side and browser side into account\n     * @return {?}\n     */\n    SlideshowComponent.prototype.loadFirstSlide = function () {\n        var _this = this;\n        var /** @type {?} */ tmpIndex = this.slideIndex;\n        var /** @type {?} */ tmpImage = this.imageUrls[tmpIndex];\n        // if server side, we don't need to worry about the rest of the slides\n        if (isPlatformServer(this.platform_id)) {\n            this.slides[tmpIndex].image = (typeof tmpImage === 'string' ? { url: tmpImage } : tmpImage);\n            this.slides[tmpIndex].loaded = true;\n            this._transferState.set(FIRST_SLIDE_KEY, this.slides[tmpIndex]);\n        }\n        else {\n            var /** @type {?} */ firstSlideFromTransferState = this._transferState.get(FIRST_SLIDE_KEY, /** @type {?} */ (null));\n            // if the first slide didn't finish loading on the server side, we need to load it\n            if (firstSlideFromTransferState === null) {\n                var /** @type {?} */ loadImage = new Image();\n                loadImage.src = (typeof tmpImage === 'string' ? tmpImage : tmpImage.url);\n                loadImage.addEventListener('load', function () {\n                    _this.slides[tmpIndex].image = (typeof tmpImage === 'string' ? { url: tmpImage } : tmpImage);\n                    _this.slides[tmpIndex].loaded = true;\n                });\n            }\n            else {\n                this.slides[tmpIndex] = firstSlideFromTransferState;\n                this._transferState.remove(FIRST_SLIDE_KEY);\n            }\n        }\n    };\n    /**\n     * \\@description if lazy loading in browser, start loading remaining slides\n     * \\@todo: figure out how to not show the spinner if images are loading fast enough\n     * @return {?}\n     */\n    SlideshowComponent.prototype.loadRemainingSlides = function () {\n        var _this = this;\n        var _loop_1 = function (i) {\n            if (!this_1.slides[i].loaded) {\n                new Promise(function (resolve) {\n                    var /** @type {?} */ tmpImage = _this.imageUrls[i];\n                    var /** @type {?} */ loadImage = new Image();\n                    loadImage.addEventListener('load', function () {\n                        _this.slides[i].image = (typeof tmpImage === 'string' ? { url: tmpImage } : tmpImage);\n                        _this.slides[i].loaded = true;\n                        resolve();\n                    });\n                    loadImage.src = (typeof tmpImage === 'string' ? tmpImage : tmpImage.url);\n                });\n            }\n        };\n        var this_1 = this;\n        for (var /** @type {?} */ i = 0; i < this.slides.length; i++) {\n            _loop_1(/** @type {?} */ i);\n        }\n    };\n    /**\n     * \\@description Start or stop autoPlay, don't do it at all server side\n     * @param {?=} stopAutoPlay\n     * @return {?}\n     */\n    SlideshowComponent.prototype.handleAutoPlay = function (stopAutoPlay) {\n        var _this = this;\n        if (isPlatformServer(this.platform_id)) {\n            return;\n        }\n        if (stopAutoPlay === true || this.autoPlay === false) {\n            if (this._autoplayIntervalId) {\n                this._ngZone.runOutsideAngular(function () { return clearInterval(_this._autoplayIntervalId); });\n                this._autoplayIntervalId = null;\n            }\n        }\n        else if (!this._autoplayIntervalId) {\n            this._ngZone.runOutsideAngular(function () {\n                _this._autoplayIntervalId = setInterval(function () {\n                    if (!_this.autoPlayWaitForLazyLoad || (_this.autoPlayWaitForLazyLoad && _this.slides[_this.slideIndex].loaded)) {\n                        _this._ngZone.run(function () { return _this.slide(1); });\n                    }\n                }, _this.autoPlayInterval);\n            });\n        }\n    };\n    /**\n     * \\@description Keep the styles up to date with the input\n     * @return {?}\n     */\n    SlideshowComponent.prototype.setStyles = function () {\n        if (this.fullscreen) {\n            this._renderer.setStyle(this.container.nativeElement, 'height', '100%');\n            // Would be nice to make it configurable\n            this._renderer.setStyle(this.container.nativeElement, 'background-color', 'white');\n        }\n        else {\n            // Would be nice to make it configurable\n            this._renderer.removeStyle(this.container.nativeElement, 'background-color');\n            if (this.height) {\n                this._renderer.setStyle(this.container.nativeElement, 'height', this.height);\n            }\n            if (this.minHeight) {\n                this._renderer.setStyle(this.container.nativeElement, 'min-height', this.minHeight);\n            }\n        }\n        if (this.arrowSize) {\n            this._renderer.setStyle(this.prevArrow.nativeElement, 'height', this.arrowSize);\n            this._renderer.setStyle(this.prevArrow.nativeElement, 'width', this.arrowSize);\n            this._renderer.setStyle(this.nextArrow.nativeElement, 'height', this.arrowSize);\n            this._renderer.setStyle(this.nextArrow.nativeElement, 'width', this.arrowSize);\n        }\n    };\n    /**\n     * \\@description compare image array to the cache, returns false if no changes\n     * @return {?}\n     */\n    SlideshowComponent.prototype.checkCache = function () {\n        var _this = this;\n        return !(this._urlCache.length === this.imageUrls.length && this._urlCache.every(function (cacheElement, i) { return cacheElement === _this.imageUrls[i]; }));\n    };\n    /**\n     * \\@description get the index for the slide to the left of the new slide\n     * @param {?=} i\n     * @return {?}\n     */\n    SlideshowComponent.prototype.getLeftSideIndex = function (i) {\n        if (i === undefined) {\n            i = this.slideIndex;\n        }\n        if (--i < 0) {\n            i = this.slides.length - 1;\n        }\n        return i;\n    };\n    /**\n     * \\@description get the index for the slide to the right of the new slide\n     * @param {?=} i\n     * @return {?}\n     */\n    SlideshowComponent.prototype.getRightSideIndex = function (i) {\n        if (i === undefined) {\n            i = this.slideIndex;\n        }\n        if (++i >= this.slides.length) {\n            i = 0;\n        }\n        return i;\n    };\n    /**\n     * \\@description a trackBy function for the ngFor loops\n     * @param {?} index\n     * @param {?} slide\n     * @return {?}\n     */\n    SlideshowComponent.prototype.trackByFn = function (index, slide) {\n        return slide.image;\n    };\n    return SlideshowComponent;\n}());\nvar SlideshowModule = /** @class */ /*@__PURE__*/ (function () {\n    function SlideshowModule() {\n    }\n    return SlideshowModule;\n}());\n/**\n * Generated bundle index. Do not edit.\n */\nexport { SlideshowModule, SlideshowComponent as ɵa, SwipeService as ɵb };\n//# sourceMappingURL=ng-simple-slideshow.es5.js.map\n",null]}